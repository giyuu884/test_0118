"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPartialAudioData = void 0;
const fetch_with_cors_catch_1 = require("./fetch-with-cors-catch");
const toUint32 = (bytes) => {
    if (bytes.length !== 4) {
        throw new Error('toUint32() requires exactly 4 bytes');
    }
    const val1 = bytes[3];
    const val2 = bytes[2];
    const val3 = bytes[1];
    const val4 = bytes[0];
    return (val1 << 24) | (val2 << 16) | (val3 << 8) | val4;
};
const toUint16 = (bytes) => {
    if (bytes.length !== 2) {
        throw new Error('toUint16() requires exactly 2 bytes');
    }
    const val1 = bytes[1];
    const val2 = bytes[0];
    return (val1 << 8) | val2;
};
const getPartialAudioData = async (src) => {
    const response = await (0, fetch_with_cors_catch_1.fetchWithCorsCatch)(src, {
        headers: {
            range: 'bytes=0-256',
        },
    });
    if (response.status !== 206) {
        throw new Error(`Tried to read bytes 0-256 from ${src}, but the response status code was not 206. This means the server might not support returning a partial response.`);
    }
    const buffer = await response.arrayBuffer();
    const uintArray = new Uint8Array(buffer);
    const header = uintArray.slice(0, 44);
    const shouldBeRiff = new TextDecoder().decode(uintArray.slice(0, 4));
    if (shouldBeRiff !== 'RIFF') {
        throw new Error('getPartialAudioData() requires a WAVE file, but the first bytes are not RIFF. ');
    }
    const size = toUint32(uintArray.slice(4, 8));
    const shouldBeWAVE = new TextDecoder().decode(uintArray.slice(8, 12));
    if (shouldBeWAVE !== 'WAVE') {
        throw new Error('getPartialAudioData() requires a WAVE file, but the bytes 8-11 are not "WAVE". ');
    }
    const shouldBeFmt = new TextDecoder().decode(uintArray.slice(12, 16));
    if (shouldBeFmt !== 'fmt ') {
        throw new Error('getPartialAudioData() requires a WAVE file, but the bytes 12-15 are not "fmt ". ');
    }
    const chunkSize = toUint32(uintArray.slice(16, 20));
    const audioFormat = toUint16(uintArray.slice(20, 22));
    if (audioFormat !== 1) {
        throw new Error('getPartialAudioData() supports only a WAVE file with PCM audio format, but the audio format is not PCM. ');
    }
    const numberOfChannels = toUint16(uintArray.slice(22, 24));
    const sampleRate = toUint32(uintArray.slice(24, 28));
    const byteRate = toUint32(uintArray.slice(28, 32));
    const blockAlign = toUint16(uintArray.slice(32, 34));
    const bitsPerSample = toUint16(uintArray.slice(34, 36));
    let offset = 36;
    const shouldBeDataOrList = new TextDecoder().decode(uintArray.slice(offset, offset + 4));
    if (shouldBeDataOrList === 'LIST') {
        const listSize = toUint32(uintArray.slice(40, 44));
        offset += listSize;
        offset += 8;
    }
    const shouldBeData = new TextDecoder().decode(uintArray.slice(offset, offset + 4));
    if (shouldBeData !== 'data') {
        throw new Error('getPartialAudioData() requires a WAVE file, but the bytes 36-39 are not "data". ');
    }
    const dataSize = toUint32(uintArray.slice(offset + 4, offset + 8));
    const numSamples = parseInt((chunkSize / blockAlign), 10);
    console.log({
        response,
        buffer,
        header,
        size,
        chunkSize,
        audioFormat,
        numberOfChannels,
        sampleRate,
        byteRate,
        blockAlign,
        bitsPerSample,
        dataSize,
        numSamples,
    });
};
exports.getPartialAudioData = getPartialAudioData;
