"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureBrowser = exports.internalEnsureBrowser = void 0;
const fs_1 = __importDefault(require("fs"));
const BrowserFetcher_1 = require("./browser/BrowserFetcher");
const browser_download_progress_bar_1 = require("./browser/browser-download-progress-bar");
const get_local_browser_1 = require("./get-local-browser");
let currentEnsureBrowserOperation = Promise.resolve();
const internalEnsureBrowserUncapped = async ({ indent, logLevel, browserExecutable, onBrowserDownload, }) => {
    const status = getBrowserStatus(browserExecutable);
    if (status.type === 'no-browser') {
        const { onProgress, version } = onBrowserDownload();
        await (0, BrowserFetcher_1.downloadBrowser)({ indent, logLevel, onProgress, version });
    }
    const newStatus = getBrowserStatus(browserExecutable);
    return newStatus;
};
const internalEnsureBrowser = (options) => {
    currentEnsureBrowserOperation = currentEnsureBrowserOperation.then(() => internalEnsureBrowserUncapped(options));
    return currentEnsureBrowserOperation;
};
exports.internalEnsureBrowser = internalEnsureBrowser;
const getBrowserStatus = (browserExecutable) => {
    if (browserExecutable) {
        if (!fs_1.default.existsSync(browserExecutable)) {
            throw new Error(`"browserExecutable" was specified as '${browserExecutable}' but the path doesn't exist. Pass "null" for "browserExecutable" to download a browser automatically.`);
        }
        return { path: browserExecutable, type: 'user-defined-path' };
    }
    const localBrowser = (0, get_local_browser_1.getLocalBrowser)();
    if (localBrowser !== null) {
        return { path: localBrowser, type: 'local-browser' };
    }
    const revision = (0, BrowserFetcher_1.getRevisionInfo)();
    if (revision.local && fs_1.default.existsSync(revision.executablePath)) {
        return { path: revision.executablePath, type: 'local-puppeteer-browser' };
    }
    return { type: 'no-browser' };
};
/**
 * Ensures a browser is locally installed so a Remotion render can be executed. This function manages the browser's download or validates existing browser paths.
 * @see [Documentation](https://remotion.dev/docs/renderer/ensure-browser)
 * @param {EnsureBrowserOptions} [options] Configuration options which may include a `browserExecutable` path, `logLevel` settings, and `onBrowserDownload` function to manage download specifics and progression.
 * @returns {Promise<void>} A promise that resolves when the browser is prepared with no explicit return value.
 */
const ensureBrowser = (options) => {
    var _a, _b, _c, _d;
    const indent = false;
    const logLevel = (_a = options === null || options === void 0 ? void 0 : options.logLevel) !== null && _a !== void 0 ? _a : 'info';
    return (0, exports.internalEnsureBrowser)({
        browserExecutable: (_b = options === null || options === void 0 ? void 0 : options.browserExecutable) !== null && _b !== void 0 ? _b : null,
        indent,
        logLevel: (_c = options === null || options === void 0 ? void 0 : options.logLevel) !== null && _c !== void 0 ? _c : 'info',
        onBrowserDownload: (_d = options === null || options === void 0 ? void 0 : options.onBrowserDownload) !== null && _d !== void 0 ? _d : (0, browser_download_progress_bar_1.defaultBrowserDownloadProgress)({
            api: 'ensureBrowser()',
            indent: false,
            logLevel,
        }),
    });
};
exports.ensureBrowser = ensureBrowser;
