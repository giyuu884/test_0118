"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineUint8Arrays = exports.padMatroskaBytes = exports.makeMatroskaBytes = exports.matroskaToHex = exports.webmPattern = void 0;
exports.serializeUint16 = serializeUint16;
/* eslint-disable @typescript-eslint/no-use-before-define */
const ebml_1 = require("./ebml");
const all_segments_1 = require("./segments/all-segments");
exports.webmPattern = new Uint8Array([0x1a, 0x45, 0xdf, 0xa3]);
const matroskaToHex = (matrId) => {
    const numbers = new Uint8Array((matrId.length - 2) / 2);
    for (let i = 2; i < matrId.length; i += 2) {
        const hex = matrId.substring(i, i + 2);
        numbers[(i - 2) / 2] = parseInt(hex, 16);
    }
    return numbers;
};
exports.matroskaToHex = matroskaToHex;
function putUintDynamic(number, minimumLength) {
    if (number < 0) {
        throw new Error('This function is designed for non-negative integers only.');
    }
    // Calculate the minimum number of bytes needed to store the integer
    const length = Math.max(minimumLength !== null && minimumLength !== void 0 ? minimumLength : 0, Math.ceil(Math.log2(number + 1) / 8));
    const bytes = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
        // Extract each byte from the number
        bytes[length - 1 - i] = (number >> (8 * i)) & 0xff;
    }
    return bytes;
}
const makeFromStructure = (fields) => {
    if ('bytes' in fields) {
        return fields;
    }
    const arrays = [];
    const struct = all_segments_1.ebmlMap[(0, all_segments_1.getIdForName)(fields.type)];
    if (struct.type === 'uint8array') {
        return {
            bytes: fields.value,
            offsets: { offset: 0, children: [], field: fields.type },
        };
    }
    if (struct.type === 'children') {
        const children = [];
        let bytesWritten = 0;
        for (const item of fields.value) {
            const { bytes, offsets } = (0, exports.makeMatroskaBytes)(item);
            arrays.push(bytes);
            children.push((0, all_segments_1.incrementOffsetAndChildren)(offsets, bytesWritten));
            bytesWritten += bytes.byteLength;
        }
        return {
            bytes: (0, exports.combineUint8Arrays)(arrays),
            offsets: { offset: 0, children, field: fields.type },
        };
    }
    if (struct.type === 'string') {
        return {
            bytes: new TextEncoder().encode(fields.value),
            offsets: {
                children: [],
                offset: 0,
                field: fields.type,
            },
        };
    }
    if (struct.type === 'uint') {
        return {
            bytes: putUintDynamic(fields.value.value, fields.value.byteLength),
            offsets: {
                children: [],
                offset: 0,
                field: fields.type,
            },
        };
    }
    if (struct.type === 'hex-string') {
        const hex = fields.value.substring(2);
        const arr = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
            const byte = parseInt(hex.substring(i, i + 2), 16);
            arr[i / 2] = byte;
        }
        return {
            bytes: arr,
            offsets: {
                children: [],
                offset: 0,
                field: fields.type,
            },
        };
    }
    if (struct.type === 'float') {
        const value = fields.value;
        if (value.size === '32') {
            const dataView = new DataView(new ArrayBuffer(4));
            dataView.setFloat32(0, value.value);
            return {
                bytes: new Uint8Array(dataView.buffer),
                offsets: {
                    children: [],
                    offset: 0,
                    field: fields.type,
                },
            };
        }
        const dataView2 = new DataView(new ArrayBuffer(8));
        dataView2.setFloat64(0, value.value);
        return {
            bytes: new Uint8Array(dataView2.buffer),
            offsets: {
                children: [],
                offset: 0,
                field: fields.type,
            },
        };
    }
    throw new Error('Unexpected type');
};
const makeMatroskaBytes = (fields) => {
    if ('bytes' in fields) {
        return fields;
    }
    const value = makeFromStructure(fields);
    const header = (0, exports.matroskaToHex)((0, all_segments_1.getIdForName)(fields.type));
    const size = (0, ebml_1.getVariableInt)(value.bytes.length, fields.minVintWidth);
    const bytes = (0, exports.combineUint8Arrays)([header, size, value.bytes]);
    return {
        bytes,
        offsets: {
            offset: value.offsets.offset,
            field: value.offsets.field,
            children: value.offsets.children.map((c) => {
                return (0, all_segments_1.incrementOffsetAndChildren)(c, header.byteLength + size.byteLength);
            }),
        },
    };
};
exports.makeMatroskaBytes = makeMatroskaBytes;
const padMatroskaBytes = (fields, totalLength) => {
    const regular = (0, exports.makeMatroskaBytes)(fields);
    const paddingLength = totalLength -
        regular.bytes.byteLength -
        (0, exports.matroskaToHex)(all_segments_1.matroskaElements.Void).byteLength;
    if (paddingLength < 0) {
        throw new Error('ooops');
    }
    const padding = (0, exports.makeMatroskaBytes)({
        type: 'Void',
        value: new Uint8Array(paddingLength).fill(0),
        minVintWidth: null,
    });
    return [
        regular,
        {
            bytes: padding.bytes,
            offsets: (0, all_segments_1.incrementOffsetAndChildren)(padding.offsets, regular.bytes.length),
        },
    ];
};
exports.padMatroskaBytes = padMatroskaBytes;
const combineUint8Arrays = (arrays) => {
    if (arrays.length === 0) {
        return new Uint8Array([]);
    }
    if (arrays.length === 1) {
        return arrays[0];
    }
    let totalLength = 0;
    for (const array of arrays) {
        totalLength += array.length;
    }
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays) {
        result.set(array, offset);
        offset += array.length;
    }
    return result;
};
exports.combineUint8Arrays = combineUint8Arrays;
function serializeUint16(value) {
    const buffer = new ArrayBuffer(2);
    const view = new DataView(buffer);
    view.setUint16(0, value);
    return new Uint8Array(buffer);
}
