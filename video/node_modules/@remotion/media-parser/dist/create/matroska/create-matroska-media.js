"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMatroskaMedia = void 0;
const ebml_1 = require("../../boxes/webm/ebml");
const make_header_1 = require("../../boxes/webm/make-header");
const all_segments_1 = require("../../boxes/webm/segments/all-segments");
const cluster_1 = require("./cluster");
const make_duration_with_padding_1 = require("./make-duration-with-padding");
const matroska_cues_1 = require("./matroska-cues");
const matroska_header_1 = require("./matroska-header");
const matroska_info_1 = require("./matroska-info");
const matroska_seek_1 = require("./matroska-seek");
const matroska_segment_1 = require("./matroska-segment");
const matroska_trackentry_1 = require("./matroska-trackentry");
const timescale = 1000000;
const createMatroskaMedia = async ({ writer, onBytesProgress, onMillisecondsProgress, filename, logLevel, progressTracker, }) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const header = (0, matroska_header_1.makeMatroskaHeader)();
    const w = await writer.createContent({ filename, mimeType: 'video/webm' });
    await w.write(header.bytes);
    const matroskaInfo = (0, matroska_info_1.makeMatroskaInfo)({
        timescale,
    });
    const currentTracks = [];
    const seeks = [];
    const cues = [];
    const trackNumbers = [];
    const matroskaSegment = (0, matroska_segment_1.createMatroskaSegment)([
        ...(0, matroska_seek_1.createMatroskaSeekHead)(seeks),
        matroskaInfo,
        ...(0, matroska_trackentry_1.makeMatroskaTracks)(currentTracks),
    ]);
    const infoSegment = matroskaSegment.offsets.children.find((o) => o.field === 'Info');
    const durationOffset = ((_b = (_a = infoSegment === null || infoSegment === void 0 ? void 0 : infoSegment.children.find((c) => c.field === 'Duration')) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0) +
        w.getWrittenByteCount();
    const tracksOffset = ((_d = (_c = matroskaSegment.offsets.children.find((o) => o.field === 'Tracks')) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0) + w.getWrittenByteCount();
    const seekHeadOffset = ((_f = (_e = matroskaSegment.offsets.children.find((o) => o.field === 'SeekHead')) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : 0) + w.getWrittenByteCount();
    const infoOffset = ((_g = infoSegment === null || infoSegment === void 0 ? void 0 : infoSegment.offset) !== null && _g !== void 0 ? _g : 0) + w.getWrittenByteCount();
    if (!seekHeadOffset) {
        throw new Error('could not get seek offset');
    }
    if (!durationOffset) {
        throw new Error('could not get duration offset');
    }
    if (!tracksOffset) {
        throw new Error('could not get tracks offset');
    }
    if (!infoOffset) {
        throw new Error('could not get tracks offset');
    }
    seeks.push({
        hexString: all_segments_1.matroskaElements.Info,
        byte: infoOffset - seekHeadOffset,
    });
    seeks.push({
        hexString: all_segments_1.matroskaElements.Tracks,
        byte: tracksOffset - seekHeadOffset,
    });
    const updateSeekWrite = async () => {
        const updatedSeek = (0, matroska_seek_1.createMatroskaSeekHead)(seeks);
        await w.updateDataAt(seekHeadOffset, (0, make_header_1.combineUint8Arrays)(updatedSeek.map((b) => b.bytes)));
        onBytesProgress(w.getWrittenByteCount());
    };
    const segmentOffset = w.getWrittenByteCount();
    const updateSegmentSize = async (size) => {
        const data = (0, ebml_1.getVariableInt)(size, matroska_segment_1.MATROSKA_SEGMENT_MIN_VINT_WIDTH);
        await w.updateDataAt(segmentOffset + (0, make_header_1.matroskaToHex)(all_segments_1.matroskaElements.Segment).byteLength, data);
        onBytesProgress(w.getWrittenByteCount());
    };
    await w.write(matroskaSegment.bytes);
    const clusterOffset = w.getWrittenByteCount();
    let currentCluster = await (0, cluster_1.makeCluster)({
        writer: w,
        clusterStartTimestamp: 0,
        timescale,
        logLevel,
    });
    seeks.push({
        hexString: all_segments_1.matroskaElements.Cluster,
        byte: clusterOffset - seekHeadOffset,
    });
    const getClusterOrMakeNew = async ({ chunk, isVideo, }) => {
        // In Safari, samples can arrive out of order, e.g public/bigbuckbunny.mp4
        // Therefore, only updating track number progress if it is a keyframe
        // to allow for timestamps to be lower than the previous one
        const smallestProgress = progressTracker.getSmallestProgress();
        if (!currentCluster.shouldMakeNewCluster({
            newT: smallestProgress,
            isVideo,
            chunk,
        })) {
            return { cluster: currentCluster, isNew: false, smallestProgress };
        }
        currentCluster = await (0, cluster_1.makeCluster)({
            writer: w,
            clusterStartTimestamp: smallestProgress,
            timescale,
            logLevel,
        });
        return { cluster: currentCluster, isNew: true, smallestProgress };
    };
    const updateDuration = async (newDuration) => {
        const blocks = (0, make_duration_with_padding_1.makeDurationWithPadding)(newDuration);
        await w.updateDataAt(durationOffset, blocks.bytes);
        onBytesProgress(w.getWrittenByteCount());
    };
    const addSample = async ({ chunk, trackNumber, isVideo, }) => {
        var _a;
        const { cluster, isNew, smallestProgress } = await getClusterOrMakeNew({
            chunk,
            isVideo,
        });
        const newDuration = Math.round((chunk.timestamp + ((_a = chunk.duration) !== null && _a !== void 0 ? _a : 0)) / 1000);
        await updateDuration(newDuration);
        const { timecodeRelativeToCluster } = await cluster.addSample(chunk, trackNumber);
        if (isNew) {
            const newCluster = w.getWrittenByteCount();
            cues.push({
                time: (0, cluster_1.timestampToClusterTimestamp)(smallestProgress, timescale) +
                    timecodeRelativeToCluster,
                clusterPosition: newCluster - seekHeadOffset,
                trackNumber,
            });
        }
        if (chunk.type === 'key') {
            progressTracker.updateTrackProgress(trackNumber, chunk.timestamp);
        }
        onBytesProgress(w.getWrittenByteCount());
        onMillisecondsProgress(newDuration);
    };
    const addTrack = async (track) => {
        currentTracks.push(track);
        const newTracks = (0, matroska_trackentry_1.makeMatroskaTracks)(currentTracks);
        progressTracker.registerTrack(track.trackNumber);
        await w.updateDataAt(tracksOffset, (0, make_header_1.combineUint8Arrays)(newTracks.map((b) => b.bytes)));
    };
    const operationProm = { current: Promise.resolve() };
    const waitForFinishPromises = [];
    return {
        updateTrackSampleRate: ({ sampleRate, trackNumber }) => {
            currentTracks.forEach((track) => {
                if (track.trackNumber === trackNumber) {
                    if (track.type !== 'audio') {
                        throw new Error('track is not audio');
                    }
                    track.sampleRate = sampleRate;
                }
            });
        },
        save: () => {
            return w.save();
        },
        remove: async () => {
            await w.remove();
        },
        addSample: ({ chunk, trackNumber, isVideo }) => {
            operationProm.current = operationProm.current.then(() => addSample({ chunk, trackNumber, isVideo }));
            return operationProm.current;
        },
        addTrack: (track) => {
            const trackNumber = currentTracks.length + 1;
            operationProm.current = operationProm.current.then(() => addTrack({ ...track, trackNumber }));
            trackNumbers.push(trackNumber);
            return operationProm.current.then(() => ({ trackNumber }));
        },
        addWaitForFinishPromise: (promise) => {
            waitForFinishPromises.push(promise);
        },
        async waitForFinish() {
            await Promise.all(waitForFinishPromises.map((p) => p()));
            await operationProm.current;
            seeks.push({
                hexString: all_segments_1.matroskaElements.Cues,
                byte: w.getWrittenByteCount() - seekHeadOffset,
            });
            await updateSeekWrite();
            await w.write((0, matroska_cues_1.createMatroskaCues)(cues).bytes);
            await w.waitForFinish();
            const segmentSize = w.getWrittenByteCount() -
                segmentOffset -
                (0, make_header_1.matroskaToHex)(all_segments_1.matroskaElements.Segment).byteLength -
                matroska_segment_1.MATROSKA_SEGMENT_MIN_VINT_WIDTH;
            await updateSegmentSize(segmentSize);
        },
    };
};
exports.createMatroskaMedia = createMatroskaMedia;
